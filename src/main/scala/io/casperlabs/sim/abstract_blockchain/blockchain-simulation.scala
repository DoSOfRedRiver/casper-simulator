package io.casperlabs.sim.abstract_blockchain

import io.casperlabs.sim.blockchain_components.execution_engine.{Transaction, ValidatorId}
import io.casperlabs.sim.simulation_framework.Timepoint

/**
  * Provides standard was of producing new simulations of blockchains.
  *
  * Implementations are responsible for:
  *   1. building a suitable blockchain infrastructure (i.e. a network of validators exchanging messages)
  *   2. deciding on how the network of validators is growing/shrinking over time.
  *   3. deciding on the physical layer of network that validators use.
  *   4. preparing a suitable simulation of clients, so for example deciding on "when a given transaction T is deployed,
  *      and towards which validator the deploy request is sent.
  */
trait BlockchainSimulationFactory[MS] {

  def createNewSimulation(
                           config: BlockchainConfig, //todo: we will have to generalize the way configuration is implemented, because config structure is different for different blockchain designs
                           transactionsStream: TransactionsStream,
                           blockchainObserver: BlockchainObserver[MS],
                           recorder: SimulationRecorder
                         ): BlockchainSimulation

}

/**
  * Abstraction of a blockchain simulation (as seen in the simulator).
  * We need this level of abstraction to compare different blockchain implementations.
  *
  * This is a stateful, process-like entity (can be controlled by starting-pausing-stopping.
  * When it runs, it:
  *   1. Consumes stream of transaction.
  *   2. Produces 3 streams of events (= block proposals, block deliveries, block finalizations).
  */
trait BlockchainSimulation {

  /**
    * Starts the simulation (at full speed).
    * This method can be called only once per simulation instance.
    */
  def start(): Unit

  /**
    * Terminates the simulation.
    */
  def stop(): Unit

  /**
    * Stops the simulation with the ability to continue.
    */
  def pause(): Unit

  /**
    * Restarts previously paused simulation.
    */
  def continue(): Unit

  /**
    * Allows slowing-down the simulation by introducing pausing in the main events queue.
    * Pause equal to 0 (zero) means running at full speed.
    *
    * @param millis length of the pause (in milliseconds)
    */
  def setPerEventPause(millis: Int)

  /**
    * Equivalent to setPerEventPause(0).
    */
  def fullSpeed(): Unit
}

/**
  * Abstraction of the transactions generator.
  * The purpose is to generate a stream of pseudo-random transactions that mimics the traffic
  * generated by clients of a real blockchain.
  *
  * Caution: the responsibility of TransactionStream is to produce transactions only.
  * Patterns of delivery (i.e. to which validator given transaction will be deployed) are to be address in another layer.
  */
trait TransactionsStream {

  /**
    * Creates next transaction.
    */
  def generateNext(): Transaction
}

/**
  * Abstraction of a consumer of data stream produced by a blockchain.
  * The purpose is to have the ability of reusing the same collection of tools (visualisers, statistics calculators, recorders)
  * against a diversity of blockchain architectures we ware going to simulate.
  *
  * @tparam MS memory states type
  */
trait BlockchainObserver[MS] {

  def blockProposed(time: Timepoint, signalledBy: ValidatorId, block: AbstractBlock)

  def blockDelivered(time: Timepoint, signalledBy: ValidatorId, block: AbstractBlock)

  def blockFinalized(time: Timepoint, signalledBy: ValidatorId, block: AbstractBlock, postState: MS)

}

trait SimulationRecorder {
  //todo either finish this or decide to make BlockchainObserver covering all data needed (so both low-level stuff and high-level stuff is available)
}
